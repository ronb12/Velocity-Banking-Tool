<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"/>
  <title>Debt Tracker</title>

  <link rel="icon" type="image/x-icon" href="favicon.ico" />
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
  <script type="module" src="utils/activityLogger.js"></script>

  <!-- PWA Scrolling Fix -->
  <script>
    // Fix PWA scrolling issues
    if (window.matchMedia('(display-mode: standalone)').matches) {
      document.addEventListener('DOMContentLoaded', function() {
        // Force enable scrolling in PWA mode
        document.body.style.overflow = 'auto';
        document.body.style.webkitOverflowScrolling = 'touch';
        document.documentElement.style.overflow = 'auto';
        document.documentElement.style.webkitOverflowScrolling = 'touch';
        
        // Prevent overscroll bounce
        document.body.style.overscrollBehavior = 'none';
        document.documentElement.style.overscrollBehavior = 'none';
        
        // Ensure proper height
        document.body.style.minHeight = '100vh';
        document.documentElement.style.height = '100%';
      });
    }
  </script>

  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      padding: 30px;
      background: #f4f7fa;
      color: #333;
    }
    nav {
      text-align: center;
      margin-bottom: 20px;
    }
    nav a {
      font-weight: bold;
      color: #007BFF;
      font-size: 16px;
      text-decoration: none;
    }
    h1 {
      text-align: center;
      color: #0056b3;
      margin-bottom: 10px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      background: #ffffff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }
    th, td {
      border: 1px solid #dee2e6;
      padding: 12px;
      text-align: center;
    }
    th {
      background-color: #007BFF;
      color: white;
      font-weight: 600;
    }
    tr:nth-child(even) {
      background-color: #f8f9fa;
    }
    .priority-urgent {
      background-color: #ffe6e6 !important;
      font-weight: bold;
      color: #c0392b;
    }
    .priority-medium {
      background-color: #fff9e6 !important;
      font-weight: bold;
      color: #e67e22;
    }
    .priority-low {
      background-color: #e6f7f0 !important;
      font-weight: bold;
      color: #2e8b57;
    }
    .priority-error {
      background-color: #fdecea !important;
      color: #b71c1c !important;
      font-weight: bold;
    }
    button {
      margin: 5px;
      padding: 8px 12px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    button:hover {
      background: #0056b3;
    }
    .summary {
      margin-top: 20px;
      font-size: 18px;
      background: #ffffff;
      padding: 12px;
      border-left: 5px solid #007bff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      border-radius: 6px;
    }
    #aiAdvisor {
      margin-top: 20px;
      padding: 16px;
      font-size: 16px;
      background: #ffffff;
      border-left: 6px solid #6f42c1;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
      line-height: 1.6;
    }
    #amortizationModal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.6);
      z-index: 1000;
    }
    #amortizationModalContent {
      background: #fff;
      width: 90%;
      max-width: 800px;
      margin: 60px auto;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      overflow-y: auto;
      max-height: 85vh;
      position: relative;
    }
    #amortizationModalContent table {
      margin-top: 10px;
      width: 100%;
      border-collapse: collapse;
    }
    #amortizationModalContent th, #amortizationModalContent td {
      padding: 10px;
      border: 1px solid #ddd;
    }
    #amortizationModalContent th {
      background: #007bff;
      color: white;
    }
    .amortization-summary {
      margin-top: 20px;
      padding: 15px;
      background: #e9f7ef;
      border: 1px solid #c3e6cb;
      border-radius: 8px;
      font-size: 16px;
      color: #155724;
    }
    .dark-mode {
      background: #333;
      color: #fff;
    }
    .dark-mode table {
      background: #444;
      color: #fff;
    }
    .dark-mode th {
      background: #555;
    }
    .dark-mode input, .dark-mode select, .dark-mode textarea {
      background: #555;
      color: #fff;
      border: 1px solid #777;
    }
  </style>
</head>
<body>
  <nav>
    <a href="index.html">‚¨ÖÔ∏è Back to Dashboard</a>
  </nav>

  <h1>Debt Tracker</h1>

  <label for="strategyToggle"><strong>Payoff Strategy:</strong></label>
  <select id="strategyToggle">
    <option value="avalanche">Avalanche (Highest Interest First)</option>
    <option value="snowball">Snowball (Smallest Balance First)</option>
  </select>

  <label for="extraPayment" style="margin-left: 20px;"><strong>Extra Monthly Payment:</strong></label>
  <input type="number" id="extraPayment" value="0" style="width: 80px;" />


  <table id="debtTable">
    <thead>
      <tr>
        <th>Debt Name</th>
        <th>Type</th>
        <th>Limit ($)</th>
        <th>Balance ($)</th>
        <th>Interest Rate (%)</th>
        <th>Min Payment ($)</th>
        <th>Months Left</th>
        <th>CFI</th>
        <th>Total Interest</th>
        <th>Priority</th>
        <th>Amortize</th>
        <th>Delete</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <button onclick="addDebt()">+ Add Debt</button>
  <button onclick="saveDebts()">üíæ Save</button>
  <button onclick="loadDebts()">üìÇ Load</button>
  <button onclick="exportAmortizationToPDF()">üìÑ Export Amortization</button>
  <button onclick="window.print()">üñ®Ô∏è Print Page</button>
  <button onclick="exportDebtsToCSV()">üìä Export to CSV</button>

  <div class="summary" id="summaryText">
    Total Debt: $0 | Total Monthly Payments: $0 | Total Interest: $0 | Total Limit: $0 | Credit Utilization: 0%
  </div>

  <div id="aiAdvisor">
    üí° Add some debts above to see intelligent recommendations appear here.
  </div>

  <!-- Amortization Modal -->
  <div id="amortizationModal">
    <div id="amortizationModalContent">
      <button onclick="closeAmortization()" style="position:absolute; top:10px; right:10px; background:#dc3545;">‚ùå Close</button>
      <h2>üìÑ Amortization Schedule</h2>
      <button onclick="exportAmortizationToPDF()" style="margin-bottom:10px;">üìÑ Export to PDF</button>
      <div id="amortizationContent"></div>
    </div>
  </div>

  <div id="loadingIndicator" style="display: none; text-align: center; margin: 20px 0;">
    <p>Loading...</p>
  </div>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyDrdga_hOO52nicYN3AwqqDjSbcnre6iM4",
  authDomain: "mobile-debt-tracker.firebaseapp.com",
  projectId: "mobile-debt-tracker"
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();
const tableBody = document.querySelector("#debtTable tbody");
const IS_LOCALHOST = ['localhost', '127.0.0.1'].includes(window.location.hostname);

const STORAGE_KEYS = {
  strategy: 'debtTracker:strategy',
  extra: 'debtTracker:extraPayment'
};

// Initialize activity logger
window.db = db;
window.auth = auth;

function formatCurrency(value) {
  const num = Number(value);
  const safe = Number.isFinite(num) ? num : 0;
  return safe.toLocaleString('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 2, maximumFractionDigits: 2 });
}

function formatPercent(value) {
  const num = Number(value);
  if (!Number.isFinite(num)) return '0.00%';
  return `${num.toFixed(2)}%`;
}

function formatMonths(months) {
  if (!Number.isFinite(months) || months <= 0) return '0 months';
  const yrs = Math.floor(months / 12);
  const mos = months % 12;
  if (yrs === 0) return `${months} month${months === 1 ? '' : 's'}`;
  return mos ? `${yrs} yr ${mos} mo` : `${yrs} yr${yrs === 1 ? '' : 's'}`;
}

function resetRowState(row) {
  row.classList.remove('priority-urgent', 'priority-medium', 'priority-low', 'priority-error');
  const priorityCell = row.querySelector('.priority');
  if (priorityCell) priorityCell.innerText = '-';
}

function addDebt(name = '', balance = '', rate = '', payment = '', limit = '', type = 'credit') {
  const row = document.createElement("tr");
  row.innerHTML = `
    <td><input value="${name}" /></td>
    <td>
      <select>
        <option value="credit" ${type === 'credit' ? 'selected' : ''}>Credit</option>
        <option value="loan" ${type === 'loan' ? 'selected' : ''}>Loan</option>
        <option value="mortgage" ${type === 'mortgage' ? 'selected' : ''}>Mortgage</option>
        <option value="other" ${type === 'other' ? 'selected' : ''}>Other</option>
      </select>
    </td>
    <td><input type="number" value="${limit}" /></td>
    <td><input type="number" value="${balance}" /></td>
    <td><input type="number" value="${rate}" /></td>
    <td><input type="number" value="${payment}" /></td>
    <td class="monthsLeft">-</td>
    <td class="cfi">-</td>
    <td class="interest">-</td>
    <td class="priority">-</td>
    <td><button onclick="amortizeRow(this)">üìÑ</button></td>
    <td><button onclick="confirmDeleteDebt(this)" style="background:#dc3545;">‚ùå</button></td>
  `;
  tableBody.appendChild(row);
  calculateSummary();
  
  // Log activity
  if (name && balance && window.activityLogger) {
    window.activityLogger.logDebtAdded(name, parseFloat(balance), parseFloat(rate));
  }
}

function calculateSummary() {
  const rows = Array.from(tableBody.querySelectorAll("tr"));
  const strategy = document.getElementById("strategyToggle").value;
  const extraInput = document.getElementById("extraPayment");
  let extraPayment = parseFloat(extraInput.value);
  if (!Number.isFinite(extraPayment) || extraPayment < 0) extraPayment = 0;

  const sortedRows = rows.slice().sort((a, b) => {
    const aBalance = parseFloat(a.querySelectorAll("input")[2].value) || 0;
    const bBalance = parseFloat(b.querySelectorAll("input")[2].value) || 0;
    const aRate = parseFloat(a.querySelectorAll("input")[3].value) || 0;
    const bRate = parseFloat(b.querySelectorAll("input")[3].value) || 0;
    if (strategy === 'snowball') {
      if (Math.abs(aBalance - bBalance) > 0.01) return aBalance - bBalance;
      return bRate - aRate;
    }
    if (Math.abs(bRate - aRate) > 0.01) return bRate - aRate;
    return aBalance - bBalance;
  });

  sortedRows.forEach(row => tableBody.appendChild(row));

  let totalBalance = 0;
  let totalPayment = 0;
  let creditBalance = 0;
  let creditLimit = 0;

  const debts = sortedRows.map((row, index) => {
    const inputs = row.querySelectorAll("input");
    const select = row.querySelector("select");
    const debt = {
      index,
      row,
      name: (inputs[0].value || '').trim() || `Debt ${index + 1}`,
      type: select.value,
      limit: parseFloat(inputs[1].value) || 0,
      balance: parseFloat(inputs[2].value) || 0,
      rate: parseFloat(inputs[3].value) || 0,
      payment: parseFloat(inputs[4].value) || 0,
      warnings: [],
      blocking: false
    };

    if (debt.balance < 0) {
      debt.warnings.push('Balance cannot be negative');
      debt.balance = 0;
    }
    if (debt.rate < 0) {
      debt.warnings.push('Rate cannot be negative');
      debt.rate = 0;
    }
    if (debt.payment < 0) {
      debt.warnings.push('Payment cannot be negative');
      debt.payment = 0;
    }
    if (debt.balance > 0 && debt.payment === 0) {
      debt.warnings.push('Enter a payment above $0');
      debt.blocking = true;
    }

    const monthlyRate = debt.rate > 0 ? debt.rate / 100 / 12 : 0;
    if (debt.balance > 0 && monthlyRate > 0 && debt.payment > 0 && debt.payment <= debt.balance * monthlyRate) {
      debt.warnings.push('Increase the payment to cover monthly interest');
      debt.blocking = true;
    }

    if (debt.type === 'credit' && debt.limit <= 0 && debt.balance > 0) {
      debt.warnings.push('Add a credit limit to calculate utilization');
    }

    totalBalance += debt.balance;
    totalPayment += Math.max(0, debt.payment);
    if (debt.type === 'credit') {
      creditBalance += debt.balance;
      creditLimit += Math.max(0, debt.limit);
    }

    resetRowState(row);
    return debt;
  });

  const hasBlocking = debts.some(d => d.blocking);
  let simulation = null;
  let baselineSimulation = null;

  if (!hasBlocking && debts.length) {
    simulation = simulatePayoff(debts, extraPayment, strategy);
    if (simulation.error) {
      const problematic = debts.find(d => d.index === simulation.debtIndex);
      if (problematic) {
        problematic.warnings.push(simulation.message);
        problematic.blocking = true;
      }
    } else if (extraPayment > 0) {
      baselineSimulation = simulatePayoff(debts, 0, strategy);
      if (baselineSimulation && baselineSimulation.error) baselineSimulation = null;
    }
  }

  const summaryElement = document.getElementById("summaryText");
  const utilization = creditLimit > 0 ? ((creditBalance / creditLimit) * 100) : 0;

  if (!simulation || simulation.error || hasBlocking) {
    debts.forEach(debt => applyRowStatus(debt, null));
    const warningPrefix = debts.some(d => d.blocking) ? '‚ö†Ô∏è ' : '';
    summaryElement.innerText = `${warningPrefix}Total Debt: ${formatCurrency(totalBalance)} | Monthly Minimums: ${formatCurrency(totalPayment)} | Revolving Limit: ${formatCurrency(creditLimit)} | Credit Utilization: ${formatPercent(utilization)}`;
    generateAdvisor({ debts, simulation: null, baselineSimulation: null, extraPayment, strategy });
    return;
  }

  debts.forEach(debt => {
    const result = simulation.debts.find(d => d.index === debt.index);
    applyRowStatus(debt, result);
  });

  markPrioritizedDebt({ debts, simulation, strategy });

  const summaryParts = [
    `Total Debt: ${formatCurrency(totalBalance)}`,
    `Monthly Minimums: ${formatCurrency(totalPayment)}`,
    extraPayment > 0 ? `Monthly w/ Extra: ${formatCurrency(totalPayment + extraPayment)}` : null,
    `Total Interest (modeled): ${formatCurrency(simulation.totalInterest)}`,
    `Revolving Limit: ${formatCurrency(creditLimit)} | Credit Utilization: ${formatPercent(utilization)}`
  ].filter(Boolean);

  const projectedDate = new Date();
  projectedDate.setMonth(projectedDate.getMonth() + simulation.maxMonths);
  summaryParts.push(`Projected Debt-Free: ${projectedDate.toLocaleDateString()}`);

  if (baselineSimulation && extraPayment > 0) {
    const monthsSaved = Math.max(0, baselineSimulation.maxMonths - simulation.maxMonths);
    const interestSaved = Math.max(0, baselineSimulation.totalInterest - simulation.totalInterest);
    if (monthsSaved > 0 || interestSaved > 0) {
      summaryParts.push(`Extra $${extraPayment.toFixed(2)}/mo saves ~${monthsSaved} month${monthsSaved === 1 ? '' : 's'} & ${formatCurrency(interestSaved)} interest`);
    }
  }

  summaryElement.innerText = summaryParts.join(' | ');
  generateAdvisor({ debts, simulation, baselineSimulation, extraPayment, strategy });
}

function applyRowStatus(debt, simulationResult) {
  const row = debt.row;
  const monthsCell = row.querySelector(".monthsLeft");
  const cfiCell = row.querySelector(".cfi");
  const interestCell = row.querySelector(".interest");
  const priorityCell = row.querySelector(".priority");

  resetRowState(row);

  if (debt.warnings.length) {
    monthsCell.innerText = '-';
    cfiCell.innerText = '-';
    interestCell.innerText = '-';
    priorityCell.innerText = `‚ö†Ô∏è ${debt.warnings[0]}`;
    row.classList.add('priority-error');
    return;
  }

  if (!simulationResult) {
    monthsCell.innerText = '-';
    cfiCell.innerText = '-';
    interestCell.innerText = '-';
    priorityCell.innerText = '-';
    return;
  }

  const cfi = debt.payment > 0 ? (debt.balance / debt.payment).toFixed(2) : '-';
  monthsCell.innerText = simulationResult.months;
  cfiCell.innerText = debt.balance > 0 && debt.payment > 0 ? cfi : '-';
  interestCell.innerText = formatCurrency(simulationResult.totalInterest);

  const months = simulationResult.months;
  if (months >= 60) {
    row.classList.add('priority-urgent');
    priorityCell.innerText = 'üî• Focus Now';
  } else if (months >= 24) {
    row.classList.add('priority-medium');
    priorityCell.innerText = '‚ö†Ô∏è Monitor';
  } else {
    row.classList.add('priority-low');
    priorityCell.innerText = '‚úÖ On Track';
  }
}

function simulatePayoff(debts, extraPayment, strategy) {
  const clones = debts.map(debt => ({
    index: debt.index,
    name: debt.name,
    balance: Math.max(0, debt.balance),
    rate: Math.max(0, debt.rate),
    payment: Math.max(0, debt.payment),
    months: 0,
    totalInterest: 0
  }));

  const MAX_MONTHS = 1200;
  let monthCounter = 0;

  while (clones.some(d => d.balance > 0.01)) {
    if (monthCounter++ > MAX_MONTHS) {
      return { error: 'iterationLimit', message: 'Could not compute payoff. Check your payments.' };
    }

    let extraPool = extraPayment;
    const active = clones.filter(d => d.balance > 0.01);
    if (!active.length) break;

    active.sort((a, b) => {
      if (strategy === 'snowball') {
        if (Math.abs(a.balance - b.balance) > 0.01) return a.balance - b.balance;
        return b.rate - a.rate;
      }
      if (Math.abs(b.rate - a.rate) > 0.01) return b.rate - a.rate;
      return a.balance - b.balance;
    });

    for (let idx = 0; idx < active.length; idx++) {
      const debt = active[idx];
      const monthlyRate = debt.rate / 100 / 12;
      const interest = debt.balance * monthlyRate;
      let payment = debt.payment;

      if (extraPool > 0) {
        payment += extraPool;
      }

      if (debt.balance > 0.01 && payment <= interest + 0.01) {
        return {
          error: 'insufficientPayment',
          debtIndex: debt.index,
          message: 'Increase the payment to cover the monthly interest.'
        };
      }

      const required = debt.balance + interest;
      if (payment > required) {
        const leftover = payment - required;
        payment = required;
        extraPool = leftover;
      } else {
        extraPool = 0;
      }

      const principal = payment - interest;
      debt.balance = Math.max(0, debt.balance - principal);
      debt.totalInterest += interest;
      debt.months += 1;
    }
  }

  const maxMonths = clones.reduce((max, debt) => Math.max(max, debt.months), 0);
  const totalInterest = clones.reduce((sum, debt) => sum + debt.totalInterest, 0);
  return { debts: clones, maxMonths, totalInterest };
}

function generateAdvisor({ debts, simulation, baselineSimulation, extraPayment, strategy }) {
  const box = document.getElementById("aiAdvisor");
  if (!debts.length) {
    box.innerHTML = "üí° Add some debts above to see intelligent recommendations appear here.";
    return;
  }

  if (!simulation || simulation.error) {
    box.innerHTML = "‚ö†Ô∏è Fix the highlighted debts above to see payoff recommendations.";
    return;
  }

  const active = simulation.debts.filter(d => d.months > 0);
  if (!active.length) {
    box.innerHTML = "‚úÖ All debts are marked as paid off.";
    return;
  }

  const longest = active.reduce((max, debt) => debt.months > max.months ? debt : max, active[0]);
  const prioritizedDebt = (() => {
    if (strategy === 'snowball') {
      return debts[0] || active[0];
    }
    return active.slice().sort((a, b) => b.rate - a.rate || b.balance - a.balance)[0];
  })();
  const targetName = debts[prioritizedDebt.index]?.name || prioritizedDebt.name || 'Your top priority';
  const targetRate = Number(prioritizedDebt.rate || debts[prioritizedDebt.index]?.rate || 0).toFixed(2);

  let html = '';
  if (strategy === 'snowball') {
    html += `<div style="color:#0d6efd;">üí∏ Focus on <strong>${targetName}</strong> first ‚Äî it's the smallest balance and will disappear fastest.</div>`;
  } else {
    html += `<div style="color:#0d6efd;">üí∏ Focus on <strong>${targetName}</strong> first ‚Äî it's carrying the highest rate at ${targetRate}%.</div>`;
  }
  html += `<div style="color:#dc3545;">‚è≥ ${debts[longest.index]?.name || 'One account'} takes about ${formatMonths(longest.months)} to clear. Consider directing extra funds here once the top priority is gone.</div>`;

  if (extraPayment > 0 && baselineSimulation) {
    const monthsSaved = Math.max(0, baselineSimulation.maxMonths - simulation.maxMonths);
    const interestSaved = Math.max(0, baselineSimulation.totalInterest - simulation.totalInterest);
    html += `<div style="color:#198754;">‚ö° Adding $${extraPayment.toFixed(2)} each month trims roughly ${monthsSaved} month${monthsSaved === 1 ? '' : 's'} and saves about ${formatCurrency(interestSaved)} in interest.</div>`;
  } else if (extraPayment <= 0) {
    html += `<div style="color:#198754;">‚ö° Try entering an extra payment above to see how quickly the payoff accelerates.</div>`;
  }

  html += `<div style="margin-top:10px;color:#6f42c1;">üìÖ Estimated debt-free date: <strong>${(function(){const date = new Date(); date.setMonth(date.getMonth() + simulation.maxMonths); return date.toLocaleDateString();})()}</strong> (${formatMonths(simulation.maxMonths)} to go).</div>`;
  box.innerHTML = html;
}

function markPrioritizedDebt({ debts, simulation, strategy }) {
  if (!simulation || !simulation.debts) return;

  const eligible = simulation.debts.filter(d => {
    const debt = debts[d.index];
    return debt && !debt.blocking && !debt.warnings.length && d.balance > 0.01;
  });
  if (!eligible.length) return;

  const prioritized = (() => {
    if (strategy === 'snowball') {
      return eligible.slice().sort((a, b) => {
        if (Math.abs(a.balance - b.balance) > 0.01) return a.balance - b.balance;
        return b.rate - a.rate;
      })[0];
    }
    return eligible.slice().sort((a, b) => {
      if (Math.abs(b.rate - a.rate) > 0.01) return b.rate - a.rate;
      return a.balance - b.balance;
    })[0];
  })();

  const debt = debts[prioritized.index];
  if (!debt) return;

  const row = debt.row;
  if (row.classList.contains('priority-error')) return;

  row.classList.remove('priority-urgent', 'priority-medium', 'priority-low');
  row.classList.add('priority-urgent');
  const label = strategy === 'snowball'
    ? 'üéØ Focus First (Snowball)'
    : 'üéØ Focus First (Avalanche)';
  const priorityCell = row.querySelector('.priority');
  if (priorityCell) priorityCell.innerText = label;
}

async function saveDebts() {
  const loadingIndicator = document.getElementById("loadingIndicator");
  loadingIndicator.style.display = "block";
  try {
    const debts = Array.from(document.querySelectorAll("#debtTable tbody tr")).map(row => ({
      name: row.cells[0].querySelector("input").value,
      type: row.cells[1].querySelector("select").value,
      limit: parseFloat(row.cells[2].querySelector("input").value) || 0,
      balance: parseFloat(row.cells[3].querySelector("input").value) || 0,
      interestRate: parseFloat(row.cells[4].querySelector("input").value) || 0,
      minPayment: parseFloat(row.cells[5].querySelector("input").value) || 0
    }));
    
    if (IS_LOCALHOST) {
      localStorage.setItem('local_test_debts', JSON.stringify(debts));
      alert("Debts saved locally for testing.");
    } else {
      console.log('Saving debts to Firestore:', debts);
      await db.collection("debts").doc(auth.currentUser.uid).set({ debts });
      
      // Log activity
      if (window.activityLogger) {
        const totalDebts = debts.length;
        const totalBalance = debts.reduce((sum, debt) => sum + debt.balance, 0);
        window.activityLogger.logActivity('debt_updated', `Updated debt portfolio: ${totalDebts} debts totaling $${totalBalance.toFixed(2)}`, '‚úèÔ∏è');
      }
      
      alert("Debts saved successfully!");
    }
  } catch (error) {
    alert("Error saving debts: " + error.message);
  } finally {
    loadingIndicator.style.display = "none";
  }
}

async function loadDebts() {
  if (IS_LOCALHOST) {
    if (loadLocalDebts()) {
      return;
    }
  }
  const loadingIndicator = document.getElementById("loadingIndicator");
  loadingIndicator.style.display = "block";
  try {
    const doc = await db.collection("debts").doc(auth.currentUser.uid).get();
    if (doc.exists) {
      const data = doc.data();
      console.log('Loading debts from Firestore:', data.debts);
      document.querySelector("#debtTable tbody").innerHTML = "";
      data.debts.forEach(debt => {
        console.log('Adding debt:', debt);
        console.log('Debt interest rate:', debt.interestRate, 'Type:', typeof debt.interestRate);
        console.log('All debt fields:', Object.keys(debt));
        console.log('Debt values:', Object.values(debt));
        addDebt(debt.name, debt.balance, debt.interestRate, debt.minPayment, debt.limit, debt.type || 'credit');
      });
      calculateSummary();
    } else if (IS_LOCALHOST && loadLocalDebts()) {
      console.log('Loaded local demo debts for offline testing.');
    }
  } catch (error) {
    console.error('Error loading debts:', error);
    if (!(IS_LOCALHOST && loadLocalDebts())) {
      alert("Error loading debts: " + error.message);
    }
  } finally {
    loadingIndicator.style.display = "none";
  }
}

function getLocalDebtsData() {
  const data = (window.getLocalTestData && window.getLocalTestData('debts')) || window.LOCAL_TEST_DATA?.debts;
  if (Array.isArray(data) && data.length) {
    return data.map(item => ({
      name: item.name,
      type: item.type || 'credit',
      limit: item.limit || 0,
      balance: item.balance || 0,
      interestRate: item.interestRate || 0,
      minPayment: item.minPayment || 0
    }));
  }
  try {
    const stored = localStorage.getItem('local_test_debts');
    return stored ? JSON.parse(stored) : [];
  } catch (err) {
    console.warn('Unable to read local debt data:', err);
    return [];
  }
}

function loadLocalDebts() {
  const sampleDebts = getLocalDebtsData();
  if (!sampleDebts.length) return false;
  document.querySelector("#debtTable tbody").innerHTML = "";
  sampleDebts.forEach(debt => addDebt(debt.name, debt.balance, debt.interestRate, debt.minPayment, debt.limit, debt.type || 'credit'));
  calculateSummary();
  return true;
}

document.addEventListener('DOMContentLoaded', () => {
  const strategySelect = document.getElementById('strategyToggle');
  const extraInput = document.getElementById('extraPayment');

  const savedStrategy = localStorage.getItem(STORAGE_KEYS.strategy);
  if (savedStrategy && Array.from(strategySelect.options).some(opt => opt.value === savedStrategy)) {
    strategySelect.value = savedStrategy;
  }

  const savedExtra = localStorage.getItem(STORAGE_KEYS.extra);
  if (savedExtra !== null && savedExtra !== '') {
    const parsed = parseFloat(savedExtra);
    if (!Number.isNaN(parsed)) {
      extraInput.value = parsed;
    }
  }

  strategySelect.addEventListener('change', () => {
    localStorage.setItem(STORAGE_KEYS.strategy, strategySelect.value);
    calculateSummary();
  });

  extraInput.addEventListener('input', () => {
    if (extraInput.value === '') {
      localStorage.removeItem(STORAGE_KEYS.extra);
    } else {
      localStorage.setItem(STORAGE_KEYS.extra, extraInput.value);
    }
    calculateSummary();
  });

  calculateSummary();
});

auth.onAuthStateChanged(user => {
  if (user) loadDebts();
  else calculateSummary();
});

if (IS_LOCALHOST) {
  document.addEventListener('DOMContentLoaded', () => {
    if (!sessionStorage.getItem('local_debts_seeded') && loadLocalDebts()) {
      sessionStorage.setItem('local_debts_seeded', 'true');
    }
  });
}

function removeRow(btn) {
  btn.closest("tr").remove();
  calculateSummary();
}

function closeAmortization() {
  document.getElementById("amortizationModal").style.display = "none";
}

function amortizeRow(button) {
  const row = button.closest("tr");
  const inputs = row.querySelectorAll("input");
  const name = inputs[0].value;
  const balance = parseFloat(inputs[2].value) || 0;
  const rate = parseFloat(inputs[3].value) || 0;
  const base = parseFloat(inputs[4].value) || 0;
  const extra = parseFloat(document.getElementById("extraPayment").value) || 0;
  const payment = base + extra;
  const content = document.getElementById("amortizationContent");
  content.innerHTML = "";

  if (balance <= 0 || rate <= 0 || payment <= 0) {
    content.innerHTML = "<p style='color:red;'>‚ùå Invalid debt data.</p>";
    document.getElementById("amortizationModal").style.display = "block";
    return;
  }

  let html = `<h3>üíº Debt: ${name}</h3><p>üí∏ Base: $${base.toFixed(2)} | ‚ûï Extra: $${extra.toFixed(2)} | üì¶ Total: $${payment.toFixed(2)} | Rate: ${rate.toFixed(2)}%</p>`;
  html += `<table><thead><tr>
    <th>Month</th><th>Payment ($)</th><th>Principal ($)</th><th>Interest ($)</th><th>Balance Remaining ($)</th>
  </tr></thead><tbody>`;

  let balanceRemaining = balance, month = 1, totalInterest = 0, totalPaid = 0;
  const monthlyRate = rate / 100 / 12;

  while (balanceRemaining > 0 && month <= 1000) {
    const interest = balanceRemaining * monthlyRate;
    let principal = payment - interest;
    if (principal > balanceRemaining) principal = balanceRemaining;
    const actual = principal + interest;
    balanceRemaining -= principal;
    totalInterest += interest;
    totalPaid += actual;

    html += `<tr>
      <td>${month}</td><td>${actual.toFixed(2)}</td><td>${principal.toFixed(2)}</td>
      <td>${interest.toFixed(2)}</td><td>${balanceRemaining.toFixed(2)}</td>
    </tr>`;
    month++;
  }

  html += `</tbody></table>
    <div class="amortization-summary">
      üìä <strong>Total Paid:</strong> $${totalPaid.toFixed(2)}<br>
      üí∏ <strong>Total Interest Paid:</strong> $${totalInterest.toFixed(2)}<br>
      üìÜ <strong>Total Months:</strong> ${month - 1}
    </div>`;
  content.innerHTML = html;
  document.getElementById("amortizationModal").style.display = "block";
}

function exportAmortizationToPDF() {
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ orientation: "landscape" });
  const content = document.getElementById("amortizationContent");

  const title = content.querySelector("h3")?.innerText || "Debt Amortization";
  const summary = Array.from(content.querySelectorAll("p, .amortization-summary")).map(el => el.innerText);
  const rows = content.querySelectorAll("table tbody tr");
  const headers = ["Month", "Payment", "Principal", "Interest", "Balance"];
  const data = Array.from(rows).map(r => Array.from(r.children).map(c => c.innerText));

  doc.setFontSize(16);
  doc.text(title, 14, 20);
  let y = 30;
  doc.setFontSize(11);
  summary.forEach(line => {
    doc.text(line, 14, y);
    y += 6;
  });

  doc.autoTable({
    head: [headers],
    body: data,
    startY: y + 4,
    theme: 'striped',
    styles: { fontSize: 9 }
  });

  doc.save("Amortization_Schedule.pdf");
}

// Input validation for debt inputs
function validateDebtInput(input) {
  const value = parseFloat(input.value);
  if (isNaN(value) || value < 0) {
    input.value = 0;
    alert("Please enter a valid positive number.");
  }
}

// Add validation to debt inputs
document.querySelectorAll("#debtTable input[type='number']").forEach(input => {
  input.addEventListener("blur", () => validateDebtInput(input));
});

// Confirmation dialog for debt deletion
function confirmDeleteDebt(button) {
  if (confirm("Are you sure you want to delete this debt?")) {
    const row = button.closest("tr");
    const debtName = row.querySelector("input").value || "Unnamed Debt";
    
    // Log activity
    if (window.activityLogger) {
      window.activityLogger.logActivity('debt_deleted', `Deleted ${debtName} debt`, 'üóëÔ∏è');
    }
    
    row.remove();
    calculateSummary();
  }
}

// Update delete button to use confirmation
document.querySelectorAll("#debtTable button[onclick*='remove']").forEach(button => {
  button.setAttribute("onclick", "confirmDeleteDebt(this)");
});

// Dark mode is now controlled globally from the profile settings

// Export debt data to CSV
function exportDebtsToCSV() {
  const debtRows = Array.from(document.querySelectorAll("#debtTable tbody tr")).map(row => ({
    name: row.cells[0].querySelector("input").value,
    type: row.cells[1].querySelector("input").value,
    limit: parseFloat(row.cells[2].querySelector("input").value) || 0,
    balance: parseFloat(row.cells[3].querySelector("input").value) || 0,
    interestRate: parseFloat(row.cells[4].querySelector("input").value) || 0,
    minPayment: parseFloat(row.cells[5].querySelector("input").value) || 0
  }));
  const csvContent = [
    ["Debt Name", "Type", "Limit", "Balance", "Interest Rate", "Min Payment"],
    ...debtRows.map(row => [row.name, row.type, row.limit, row.balance, row.interestRate, row.minPayment])
  ].map(row => row.join(",")).join("\n");
  const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = "debt_data.csv";
  link.click();
}
</script>
</body>
</html>
